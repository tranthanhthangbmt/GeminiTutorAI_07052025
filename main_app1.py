# change for gemini-2.0-flash
import os
import streamlit as st
import requests
from dotenv import load_dotenv
import fitz  # = PyMuPDF
import io
import re
import streamlit.components.v1 as components
import docx #d√πng ƒë·ªÉ ƒë·ªçc file ng∆∞·ªùi d√πng upload l√™n
from bs4 import BeautifulSoup
import streamlit.components.v1 as components
from streamlit_javascript import st_javascript
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
import tempfile
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont

#from gtts import gTTS #for audio
import edge_tts #AI audio
import asyncio  #AI audio 

import base64
import uuid
import os

from firebase_admin import firestore  # ‚ú® Th√™m d√≤ng n√†y ·ªü ƒë·∫ßu file ch√≠nh



from datetime import datetime
from google.cloud.firestore_v1 import ArrayUnion

import json

# ƒê·∫£m b·∫£o st.set_page_config l√† l·ªánh ƒë·∫ßu ti√™n
# Giao di·ªán Streamlit
st.set_page_config(page_title="Tutor AI", page_icon="üéì")

if "toc_html" not in st.session_state:
    st.session_state["toc_html"] = "<p><em>Ch∆∞a c√≥ m·ª•c l·ª•c b√†i h·ªçc.</em></p>"

#for menu content
import streamlit.components.v1 as components

from modules.content_parser import (
    clean_text,
    make_id,
    classify_section,
    parse_pdf_file,
    parse_docx_file,
    parse_uploaded_file,
	tach_noi_dung_bai_hoc_tong_quat
)

from modules.session_manager import (
    generate_session_id,
    init_session_state,
    init_lesson_progress,
    save_lesson_progress,
    load_lesson_progress_from_file,
    merge_lesson_progress,
    update_progress,
    get_current_session_info
)

from modules.progress_tracker import (
    get_progress_summary,
    list_incomplete_parts,
    get_low_understanding_parts,
    mark_part_review_needed,
    get_progress_table
)

from modules.audio_module import (
    generate_audio_filename,
    generate_audio_async,
    play_audio,
    generate_and_encode_audio
)
    
def render_audio_block(text: str, autoplay=False):
    b64 = generate_and_encode_audio(text)
    autoplay_attr = "autoplay" if autoplay else ""
    st.markdown(f"""
    <audio controls {autoplay_attr}>
        <source src="data:audio/mp3;base64,{b64}" type="audio/mp3">
        Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ph√°t √¢m thanh.
    </audio>
    """, unsafe_allow_html=True)
    

from modules.firestore_logger import (
    save_exchange_to_firestore,
    save_part_feedback,
    get_history
)

from modules.file_reader import (
    extract_text_from_uploaded_file,
    extract_pdf_text_from_url    
)

from modules.text_utils import (
    clean_html_to_text,
    format_mcq_options,
    convert_to_mathjax,
    convert_to_mathjax1,
    convert_parentheses_to_latex,
    extract_headings_with_levels,
    generate_sidebar_radio_from_headings
    
)

from modules.firebase_config import init_firestore  # üõ† ƒê·ª´ng qu√™n d√≤ng n√†y n·ªØa n·∫øu d√πng Firestore
#kh·ªüi t·∫°o db
db = init_firestore()

doc_reading_enabled = False

#from dashboard import show_progress_dashboard, show_part_detail_table

#for data firebase
if "firebase_enabled" not in st.session_state:
    st.session_state["firebase_enabled"] = True # False  # ho·∫∑c True n·∫øu mu·ªën m·∫∑c ƒë·ªãnh b·∫≠t
    
import uuid
import time

if "session_id" not in st.session_state:
    # d√πng timestamp ho·∫∑c uuid ng·∫Øn g·ªçn
    st.session_state["session_id"] = f"{int(time.time())}"  # ho·∫∑c uuid.uuid4().hex[:8]

if "user_id" not in st.session_state:
    st.session_state["user_id"] = f"user_{uuid.uuid4().hex[:8]}"
    
#m·ªü l·∫°i danh s√°ch c√°c b√†i h·ªçc
st.session_state["show_sidebar_inputs"] = True

#thi·∫øt l·∫≠p font size
st.markdown("""
<style>
    .element-container .markdown-text-container {
        font-size: 17px;
        line-height: 1.7;
    }
    code {
        background-color: #f4f4f4;
        padding: 2px 4px;
        border-radius: 4px;
        font-size: 15px;
    }
    h3 {
        color: #2a73cc;
        margin-top: 1.5em;
    }
</style>
""", unsafe_allow_html=True)

st.markdown("""
<style>
h1 {
    font-size: 24px !important;
    line-height: 1.5;
    font-weight: 600;
}
h2 {
    font-size: 21px !important;
}
h3 {
    font-size: 19px !important;
}
</style>
""", unsafe_allow_html=True)

uploaded_files = []  # ‚úÖ ƒë·∫£m b·∫£o bi·∫øn t·ªìn t·∫°i trong m·ªçi tr∆∞·ªùng h·ª£p

input_key = st.session_state.get("GEMINI_API_KEY", "")

# L·∫•y t·ª´ localStorage
key_from_local = st_javascript("JSON.parse(window.localStorage.getItem('gemini_api_key') || '\"\"')")

# N·∫øu ch∆∞a c√≥ th√¨ g√°n
if not input_key and key_from_local:
    st.session_state["GEMINI_API_KEY"] = key_from_local
    input_key = key_from_local

# L·∫•y danh s√°ch API keys t·ª´ secrets
api_keys = st.secrets["gemini_keys"]["keys"]
api_index = 0  # Index ban ƒë·∫ßu

# H√†m g·ªçi API v·ªõi c∆° ch·∫ø th·ª≠ nhi·ªÅu key
def call_api_with_fallback(request_func):
    global api_index
    max_attempts = len(api_keys)

    for attempt in range(max_attempts):
        current_key = api_keys[api_index]
        try:
            # G·ªçi h√†m truy·ªÅn v√†o v·ªõi API key hi·ªán t·∫°i
            return request_func(current_key)
        except Exception as e:
            st.warning(f"API key {current_key} failed with error: {e}")
            api_index = (api_index + 1) % max_attempts  # chuy·ªÉn sang key ti·∫øp theo
    raise RuntimeError("All API keys failed.")

def get_data(api_key):
    response = some_api_call(api_key=api_key)
    if response.status_code != 200:
        raise Exception(f"Bad status: {response.status_code}")
    return response.json()
    
@st.cache_data
def load_available_lessons_from_txt(url):
    try:
        #response = requests.get(url)
        response = requests.get(url, allow_redirects=True)
        if response.status_code == 200:
            lines = response.text.strip().splitlines()
            lessons = {"üëâ Ch·ªçn b√†i h·ªçc...": ""}
            for line in lines:
                if "|" in line:
                    name, link = line.split("|", 1)
                    lessons[name.strip()] = link.strip()
            return lessons
        else:
            st.warning("‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫£i danh s√°ch b√†i h·ªçc t·ª´ GitHub.")
            return {"üëâ Ch·ªçn b√†i h·ªçc...": ""}
    except Exception as e:
        st.error(f"L·ªói khi ƒë·ªçc danh s√°ch b√†i h·ªçc: {e}")
        return {"üëâ Ch·ªçn b√†i h·ªçc...": ""}
        
LESSON_LIST_URL = "https://raw.githubusercontent.com/tranthanhthangbmt/AITutor_Gemini/main/Data/DiscreteMathematicsLesson3B.txt"  
available_lessons = load_available_lessons_from_txt(LESSON_LIST_URL) 

#vi·∫øt cho ƒë·∫πp h∆°n
def format_pdf_text_for_display(raw_text: str) -> str:
    text = raw_text.strip()

    # ‚úÖ 1. X·ª≠ l√Ω k√Ω t·ª± l·ªói & l·ªói t√°ch t·ª´
    text = text.replace("ÔøΩ", "")
    text = re.sub(r"\bch\s*‚Ä¢", "cho ", text)
    text = re.sub(r"\bsa\s*‚Ä¢", "sao ", text)
    text = re.sub(r"\bthe\s*‚Ä¢", "theo ", text)
    text = re.sub(r"\bD\s*‚Ä¢", "Do ", text)
    text = re.sub(r"\bch\s+", "cho ", text)
    text = re.sub(r"\bT·∫°\s*", "T·∫°o ", text)

    # ‚úÖ 2. Chu·∫©n h√≥a g·∫°ch ƒë·∫ßu d√≤ng ‚Üí xu·ªëng d√≤ng
    text = re.sub(r"\s*[‚Ä¢\-‚Äì‚óèüîπüî∑]+\s*", r"\n‚Ä¢ ", text)
    text = re.sub(r"(?<!\n)‚Ä¢ ", r"\n‚Ä¢ ", text)

    # ‚úÖ 3. T√°ch c√¢u sau d·∫•u ch·∫•m n·∫øu sau ƒë√≥ l√† ch·ªØ hoa
    text = re.sub(r"(?<=[a-z0-9])\. (?=[A-Z])", ".\n", text)

    # ‚úÖ 4. L√†m n·ªïi b·∫≠t nh√≥m ti√™u ƒë·ªÅ b·∫±ng **Markdown**
    heading_keywords = [
        "ƒê·ªãnh l√Ω", "V√≠ d·ª•", "L∆∞u √Ω", "Ghi ch√∫", "Nh·∫≠n x√©t",
        "H·ªá qu·∫£", "B·ªï ƒë·ªÅ", "T√≥m t·∫Øt", "·ª®ng d·ª•ng", "Ph√¢n t√≠ch",
        "B√†i to√°n", "Thu·∫≠t to√°n", "√ù nghƒ©a", "K·∫øt lu·∫≠n", "M√¥ h√¨nh h√≥a",
        "Gi·∫£i th√≠ch", "Ph√¢n t√≠ch chi ti·∫øt", "ƒê·ªãnh nghƒ©a", "L·ªùi gi·∫£i"
    ]
    for kw in heading_keywords:
        text = re.sub(
            rf"(?<!\*)\b({kw}(?: [0-9]+)?(?: \([^)]+\))?:?)",
            r"\n\n**\1**", text
        )

    # ‚úÖ 5. ƒê∆∞a PH·∫¶N v√† B√†i th√†nh ti√™u ƒë·ªÅ h3
    text = re.sub(r"\b(PH·∫¶N\s*\d+[:Ôºö])", r"\n\n### \1", text, flags=re.IGNORECASE)
    text = re.sub(r"\b(B√†i\s*\d+[:Ôºö])", r"\n\n**\1**", text, flags=re.IGNORECASE)

    # ‚úÖ 6. L√†m r√µ to√°n h·ªçc
    text = text.replace("=>", "‚áí").replace("<=", "‚áê").replace("=", " = ")

    # ‚úÖ 7. Format ƒëo·∫°n code: ph√°t hi·ªán l·ªánh Python ‚Üí th√™m ```python ```
    if "import " in text or "def " in text:
        text = re.sub(
            r"(import .+?)(?=\n\S|\Z)", r"\n```python\n\1\n```\n", text, flags=re.DOTALL
        )
        text = re.sub(
            r"(def .+?)(?=\n\S|\Z)", r"\n```python\n\1\n```\n", text, flags=re.DOTALL
        )

    # ‚úÖ 8. G·ªôp d√≤ng tr·∫Øng th·ª´a
    text = re.sub(r"\n{3,}", "\n\n", text)

    return text.strip()
    
# X√°c th·ª±c API b·∫±ng request test
def is_valid_gemini_key(key):
    try:
        test_response = requests.post(
            GEMINI_API_URL,
            headers={"Content-Type": "application/json"},
            params={"key": key},
            json={"contents": [{"parts": [{"text": "hello"}]}]},
            timeout=5
        )
        return test_response.status_code == 200
    except Exception:
        return False

#thi·∫øt l·∫≠p ·∫©n ph·∫ßn b√†i h·ªçc
if "show_sidebar_inputs" not in st.session_state:
    st.session_state["show_sidebar_inputs"] = True  # ‚Üê b·∫≠t m·∫∑c ƒë·ªãnh

import random

# L·∫•y danh s√°ch API keys t·ª´ secrets (v√≠ d·ª• t·ª´ m·ª•c [openai_keys] ho·∫∑c [gemini_keys])
def get_random_key():
    return random.choice(st.secrets["gemini_keys"]["keys"])


# ‚¨á L·∫•y input t·ª´ ng∆∞·ªùi d√πng ·ªü sidebar tr∆∞·ªõc
with st.sidebar:
    st.markdown("""
    <style>
    /* ·∫®n ho√†n to√†n iframe t·∫°o b·ªüi st_javascript (v·∫´n ho·∫°t ƒë·ªông, ch·ªâ kh√¥ng chi·∫øm kh√¥ng gian) */
    iframe[title="streamlit_javascript.streamlit_javascript"] {
        display: none !important;
    }
    
    /* ·∫®n container ch·ª©a iframe (ch√≠nh l√† div t·∫°o kho·∫£ng tr·ªëng) */
    div[data-testid="stCustomComponentV1"] {
        display: none !important;
    }
    </style>
    """, unsafe_allow_html=True)
    
    #for logo
    # Thay link n√†y b·∫±ng logo th·∫≠t c·ªßa b·∫°n (link raw t·ª´ GitHub)
    logo_url = "https://raw.githubusercontent.com/tranthanhthangbmt/AITutor_Gemini/main/LOGO_UDA_2023_VN_EN_chuan2.png"

    st.sidebar.markdown(
        f"""
        <div style='text-align: center; margin-bottom: 10px;'>
            <img src="{logo_url}" width="200" style="border-radius: 10px;" />
        </div>
        """,
        unsafe_allow_html=True
    )

    # üìå L·ª±a ch·ªçn ch·∫ø ƒë·ªô nh·∫≠p b√†i h·ªçc
    #cho upload file tr∆∞·ªõc
    #mode = st.radio("üìò Ch·∫ø ƒë·ªô nh·∫≠p b√†i h·ªçc:", ["T·∫£i l√™n th·ªß c√¥ng", "Ch·ªçn t·ª´ danh s√°ch"])
    #ch·ªçn b√†i h·ªçc tr∆∞·ªõc
    mode = st.radio(
        "üìò Ch·∫ø ƒë·ªô nh·∫≠p b√†i h·ªçc:", 
        ["T·∫£i l√™n th·ªß c√¥ng", "Ch·ªçn t·ª´ danh s√°ch"],
        index=1  # ‚úÖ M·∫∑c ƒë·ªãnh ch·ªçn "T·∫£i l√™n th·ªß c√¥ng"
    )
    st.session_state["show_sidebar_inputs"] = (mode == "Ch·ªçn t·ª´ danh s√°ch")

    # ‚úÖ Nh√∫ng script JS duy nh·∫•t ƒë·ªÉ t·ª± ƒë·ªông ƒëi·ªÅn & l∆∞u API key
    key_from_local = st_javascript("""
    (() => {
        const inputEl = window.parent.document.querySelector('input[data-testid="stTextInput"][type="password"]');
        const storedKey = localStorage.getItem("gemini_api_key");
    
        // T·ª± ƒë·ªông ƒëi·ªÅn n·∫øu textbox r·ªóng
        if (inputEl && storedKey && inputEl.value === "") {
            inputEl.value = JSON.parse(storedKey);
            inputEl.dispatchEvent(new Event("input", { bubbles: true }));
        }
    
        // L∆∞u khi ng∆∞·ªùi d√πng nh·∫≠p
        const saveAPI = () => {
            if (inputEl && inputEl.value) {
                localStorage.setItem("gemini_api_key", JSON.stringify(inputEl.value));
            }
        };
        inputEl?.addEventListener("blur", saveAPI);
        inputEl?.addEventListener("change", saveAPI);
        inputEl?.addEventListener("keydown", e => {
            if (e.key === "Enter") saveAPI();
        });
    
        return storedKey ? JSON.parse(storedKey) : "";
    })()
    """)
    
    # ‚úÖ ∆Øu ti√™n l·∫•y t·ª´ localStorage n·∫øu session ch∆∞a c√≥
    input_key = st.session_state.get("GEMINI_API_KEY", "")
    if not input_key and key_from_local:
        st.session_state["GEMINI_API_KEY"] = key_from_local
        input_key = key_from_local
    
    # ‚úÖ T·∫°o textbox v·ªõi gi√° tr·ªã ƒë√∫ng
    #input_key = st.text_input("üîë Gemini API Key", value=input_key, type="password", key="GEMINI_API_KEY")
    # ‚úÖ T·∫°o textbox v·ªõi gi√° tr·ªã ƒë√∫ng
    # ‚úÖ T·∫°o textbox v·ªõi gi√° tr·ªã ƒë√∫ng
    if "GEMINI_API_KEY" not in st.session_state or st.session_state.GEMINI_API_KEY == "":
        # L·∫•y random API key t·ª´ danh s√°ch n·∫øu ch∆∞a c√≥ s·∫µn
        input_key = get_random_key()
        st.session_state.GEMINI_API_KEY = input_key
    else:
        input_key = st.session_state.GEMINI_API_KEY
    
    #input_key = st.text_input("üîë Gemini API Key", value=input_key, type="password", key="GEMINI_API_KEY")
    # ‚ùó ·∫®n √¥ nh·∫≠p n·∫øu ch∆∞a c√≥ t√†i li·ªáu ho·∫∑c b√†i h·ªçc
    selected_lesson_val = st.session_state.get("selected_lesson", "üëâ Ch·ªçn b√†i h·ªçc...")
    has_lesson = not (
        selected_lesson_val == "üëâ Ch·ªçn b√†i h·ªçc..." and not uploaded_files
    )
    
    # if has_lesson:
    #     input_key = st.text_input("üîë Gemini API Key", value=input_key, type="password", key="GEMINI_API_KEY")

    # üîÑ Ch·ªçn m√¥ h√¨nh Gemini
    model_options = {
        "‚ö° Gemini 2.0 Flash": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "‚ö° Gemini 1.5 Flash": "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent",
        "üß† Gemini 1.5 Pro": "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent",
        "üß† Gemini 2.5 Pro Preview": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-03-25:generateContent",
        "üß™ Gemini 2.5 Pro Experimental": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-exp-03-25:generateContent",
        "üñºÔ∏è Gemini 1.5 Pro Vision (·∫£nh + ch·ªØ)": "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-vision:generateContent"
    }
    
    # ‚úÖ Hi·ªÉn th·ªã selectbox
    selected_model_name = st.selectbox("ü§ñ Ch·ªçn m√¥ h√¨nh Gemini", list(model_options.keys()), index=0)
    
    # ‚úÖ G√°n URL t∆∞∆°ng ·ª©ng v√†o session_state (ƒë·ªÉ d√πng sau)
    st.session_state["GEMINI_API_URL"] = model_options[selected_model_name]

    st_javascript("""
    (() => {
        const inputEl = window.parent.document.querySelector('input[data-testid="stTextInput"][type="password"]');
        const storedKey = localStorage.getItem("gemini_api_key");
    
        // T·ª± ƒëi·ªÅn n·∫øu c√≤n tr·ªëng
        const tryFillKey = () => {
            if (inputEl && storedKey && inputEl.value.trim() === "") {
                inputEl.value = JSON.parse(storedKey);
                inputEl.dispatchEvent(new Event("input", { bubbles: true }));
                console.log("‚úÖ T·ª± ƒë·ªông ƒëi·ªÅn API t·ª´ localStorage.");
            }
        };
    
        tryFillKey();  // g·ªçi ngay khi ch·∫°y
        const interval = setInterval(tryFillKey, 1000); // ki·ªÉm tra l·∫°i m·ªói gi√¢y
    
        // L∆∞u khi thay ƒë·ªïi
        const saveAPI = () => {
            if (inputEl && inputEl.value) {
                localStorage.setItem("gemini_api_key", JSON.stringify(inputEl.value));
                console.log("üíæ ƒê√£ l∆∞u API v√†o localStorage.");
            }
        };
    
        inputEl?.addEventListener("change", saveAPI);
        inputEl?.addEventListener("blur", saveAPI);
        inputEl?.addEventListener("keydown", (e) => {
            if (e.key === "Enter") saveAPI();
        });
    })();
    """)
    "[L·∫•y API key t·∫°i ƒë√¢y](https://aistudio.google.com/app/apikey)"
    # üîä Cho ph√©p b·∫≠t/t·∫Øt t·ª± ƒë·ªông ph√°t audio
    enable_audio_default = True  # ‚úÖ M·∫∑c ƒë·ªãnh: B·∫≠t nghe audio
    st.session_state["enable_audio_playback"] = st.sidebar.checkbox("üîä T·ª± ƒë·ªông ph√°t √¢m thanh", value=enable_audio_default)
    if st.session_state.get("show_sidebar_inputs", False):
        st.markdown("üìö **Ch·ªçn b√†i h·ªçc ho·∫∑c t·∫£i l√™n b√†i h·ªçc**")
        
        selected_lesson = st.selectbox("üìñ Ch·ªçn b√†i h·ªçc", list(available_lessons.keys()))
        st.session_state["selected_lesson"] = selected_lesson
        default_link = available_lessons[selected_lesson]
        selected_lesson_link = available_lessons.get(selected_lesson, "").strip()
        
        if selected_lesson != "üëâ Ch·ªçn b√†i h·ªçc..." and selected_lesson_link:
            st.markdown(f"üîó **T√†i li·ªáu:** [Xem b√†i h·ªçc]({selected_lesson_link})", unsafe_allow_html=True)
    else:
        # uploaded_file = None #b·ªè v√¨ b·∫°n c√≥ th·ªÉ x√≥a d√≤ng n√†y n·∫øu ƒë√£ chuy·ªÉn sang uploaded_files:
        selected_lesson = "üëâ Ch·ªçn b√†i h·ªçc..."        
        selected_lesson_link = "" #available_lessons.get(selected_lesson, "").strip() """
        uploaded_files = st.file_uploader(
            "üì§ T·∫£i l√™n nhi·ªÅu file b√†i h·ªçc (PDF, TXT, DOCX, JSON)", 
            type=["pdf", "txt", "docx", "json"],  # ‚û° th√™m "json" v√†o ƒë√¢y
            accept_multiple_files=True,
            key="file_uploader_thutay"
        )

        # Ki·ªÉm tra s·ªë file v√† k√≠ch th∆∞·ªõc t·ªïng c·ªông
        MAX_FILE_COUNT = 3
        MAX_TOTAL_SIZE_MB = 5
        
        if uploaded_files:
            total_size = sum(file.size for file in uploaded_files) / (1024 * 1024)
            if len(uploaded_files) > MAX_FILE_COUNT:
                st.warning(f"‚ö†Ô∏è Ch·ªâ n√™n t·∫£i t·ªëi ƒëa {MAX_FILE_COUNT} file.")
            elif total_size > MAX_TOTAL_SIZE_MB:
                st.warning(f"‚ö†Ô∏è T·ªïng dung l∆∞·ª£ng file v∆∞·ª£t qu√° {MAX_TOTAL_SIZE_MB}MB.")

    default_link = available_lessons[selected_lesson]
    # üì§ T·∫£i file t√†i li·ªáu (m·ª•c ti√™u l√† ƒë·∫∑t b√™n d∆∞·ªõi link)
    #uploaded_file = None  # Kh·ªüi t·∫°o tr∆∞·ªõc ƒë·ªÉ d√πng ƒëi·ªÅu ki·ªán b√™n tr√™n
    
    # üîó Hi·ªÉn th·ªã link NGAY B√äN D∆Ø·ªöI selectbox, n·∫øu th·ªèa ƒëi·ªÅu ki·ªán
    #if selected_lesson != "üëâ Ch·ªçn b√†i h·ªçc..." and selected_lesson_link:
    #    st.markdown(f"üîó **T√†i li·ªáu:** [Xem b√†i h·ªçc]({selected_lesson_link})", unsafe_allow_html=True)
    
    # ‚úÖ N·∫øu ng∆∞·ªùi d√πng upload t√†i li·ªáu ri√™ng ‚Üí ·∫©n link (t·ª´ v√≤ng sau tr·ªü ƒëi)
    if uploaded_files:
        # C√≥ th·ªÉ xo√° d√≤ng link b·∫±ng session ho·∫∑c kh√¥ng hi·ªÉn th·ªã ·ªü c√°c ph·∫ßn sau
        pass
    #hi·ªÉn th·ªã danh s√°ch c√°c files ƒë√£ upload l√™n
    if uploaded_files:
        st.markdown("üìÑ **C√°c file ƒë√£ t·∫£i l√™n:**")
        for f in uploaded_files:
            st.markdown(f"- {f.name}")

    # ‚úÖ CSS ƒë·ªÉ gi·∫£m kho·∫£ng c√°ch gi·ªØa c√°c n√∫t trong sidebar
    st.markdown("""
        <style>
        /* Lo·∫°i b·ªè kho·∫£ng c√°ch gi·ªØa c√°c n√∫t trong sidebar */
        div[data-testid="stSidebar"] div[data-testid="stButton"] {
            margin-bottom: 2px;
        }
    
        /* T√πy ch·ªânh n√∫t ho√†n th√†nh */
        .completed-btn > button {
            background-color: #d4edda !important;
            color: black !important;
            width: 100%;
            text-align: left;
        }
    
        /* T√πy ch·ªânh n√∫t ch∆∞a ho√†n th√†nh */
        .incomplete-btn > button {
            background-color: #f8f9fa !important;
            color: black !important;
            width: 100%;
            text-align: left;
        }
        </style>
    """, unsafe_allow_html=True)
    
    show_content = st.sidebar.checkbox("üìë M·ª•c l·ª•c b√†i h·ªçc", value=True)
    #doc_reading_enabled = st.checkbox("‚úÖ ƒê·ªçc n·ªôi dung b√†i h·ªçc tr∆∞·ªõc khi ƒë·ªçc c√¢u h·ªèi", value=False)
    # Hi·ªÉn th·ªã checkbox cho ng∆∞·ªùi d√πng
    read_lesson_first = st.checkbox("ƒê·ªçc n·ªôi dung b√†i h·ªçc", value=False)
    
    #with st.sidebar.expander("üìë Content ‚Äì M·ª•c l·ª•c b√†i h·ªçc", expanded=True):
    # if show_content:
    #     #st.markdown("üß† **Ch·ªçn m·ªôt m·ª•c b√™n d∆∞·ªõi ƒë·ªÉ b·∫Øt ƒë·∫ßu:**", unsafe_allow_html=True)
    
    #     lesson_parts = st.session_state.get("lesson_parts", [])
    #     options = ["__none__"]  # option m·∫∑c ƒë·ªãnh
    #     option_labels = ["-- Ch·ªçn m·ª•c ƒë·ªÉ b·∫Øt ƒë·∫ßu --"]
        
    #     for idx, part in enumerate(lesson_parts):
    #         part_id = part["id"]
    #         tieu_de = part.get("tieu_de", "Kh√¥ng c√≥ ti√™u ƒë·ªÅ")
    #         progress_item = next((p for p in st.session_state.get("lesson_progress", []) if p["id"] == part_id), {})
    #         trang_thai = progress_item.get("trang_thai", "chua_hoan_thanh")
        
    #         label = f"‚úÖ {part_id} ‚Äì {tieu_de}" if trang_thai == "hoan_thanh" else f"{part_id} ‚Äì {tieu_de}"
    #         options.append(f"{part_id}|{idx}")
    #         option_labels.append(label)
        
    #     # D√πng radio nh∆∞ b√¨nh th∆∞·ªùng
    #     selected_raw = st.radio(
    #         "Ch·ªçn m·ª•c ƒë·ªÉ h·ªçc:",
    #         options=options,
    #         format_func=lambda x: option_labels[options.index(x)],
    #         key="selected_part_radio"
    #     )
        
    #     # B·ªè qua n·∫øu ch∆∞a ch·ªçn
    #     if selected_raw != "__none__":
    #         part_id, idx = selected_raw.split("|")
    #         new_selection = lesson_parts[int(idx)]
        
    #         # So s√°nh tr√°nh c·∫≠p nh·∫≠t d∆∞ th·ª´a
    #         current = st.session_state.get("selected_part_for_discussion", {})
    #         if current.get("id") != part_id:
    #             st.session_state["selected_part_for_discussion"] = new_selection
    #             st.session_state["force_ai_to_ask"] = True
    # if show_content:
    #     lesson_parts = st.session_state.get("lesson_parts", [])
    #     options = ["__none__"]
    #     option_labels = ["-- Ch·ªçn m·ª•c ƒë·ªÉ b·∫Øt ƒë·∫ßu --"]
    
    #     for idx, part in enumerate(lesson_parts):
    #         part_id = part["id"]
    #         tieu_de = part.get("tieu_de", "Kh√¥ng c√≥ ti√™u ƒë·ªÅ")
    #         heading_level = part.get("heading_level", 0)
    
    #         # Tr·∫°ng th√°i h·ªçc
    #         progress_item = next(
    #             (p for p in st.session_state.get("lesson_progress", []) if p["id"] == part_id), {}
    #         )
    #         trang_thai = progress_item.get("trang_thai", "chua_hoan_thanh")
    
    #         # ‚úÖ Th·ª•t ƒë·∫ßu d√≤ng theo heading_level b·∫±ng d·∫•u hi·ªÉn th·ªã r√µ
    #         indent_symbols = ["", "‚û§ ", "‚ÄÉ‚ÄÉ‚Ä¢ ", "‚ÄÉ‚ÄÉ‚ÄÉ‚Üí ", "‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ó¶ "]
    #         indent = indent_symbols[min(heading_level, len(indent_symbols) - 1)]
    
    #         prefix = "‚úÖ " if trang_thai == "hoan_thanh" else ""
    #         label = f"{indent}{prefix}{part_id} ‚Äì {tieu_de}"
    
    #         options.append(f"{part_id}|{idx}")
    #         option_labels.append(label)
    
    #     # Radio selector
    #     selected_raw = st.radio(
    #         "Ch·ªçn m·ª•c ƒë·ªÉ h·ªçc:",
    #         options=options,
    #         format_func=lambda x: option_labels[options.index(x)],
    #         key="selected_part_radio"
    #     )
    
    #     # X·ª≠ l√Ω khi ng∆∞·ªùi d√πng ch·ªçn m·ª•c
    #     if selected_raw != "__none__":
    #         part_id, idx = selected_raw.split("|")
    #         new_selection = lesson_parts[int(idx)]
    
    #         current = st.session_state.get("selected_part_for_discussion", {})
    #         if current.get("id") != part_id:
    #             st.session_state["selected_part_for_discussion"] = new_selection
    #             st.session_state["force_ai_to_ask"] = True

    if show_content:
        # B∆∞·ªõc 1: L·∫•y danh s√°ch headings t·ª´ lesson_parts
        lesson_parts = st.session_state.get("lesson_parts", [])
        headings = []

        for idx, part in enumerate(lesson_parts):
            level = part.get("heading_level", 0)
            headings.append((level, {
                "id": part["id"],
                "tieu_de": part.get("tieu_de", "Kh√¥ng c√≥ ti√™u ƒë·ªÅ"),
            }))
    
        # B∆∞·ªõc 2: G·ªçi h√†m generate_sidebar_radio_from_headings
        def custom_sidebar_radio(headings):
            options = ["__none__"]
            labels = ["-- Ch·ªçn m·ª•c ƒë·ªÉ b·∫Øt ƒë·∫ßu --"]
            #prefix_symbols = ["", "‚û§ ", "‚ÄÉ‚ÄÉ‚Ä¢ ", "‚ÄÉ‚ÄÉ‚ÄÉ‚Üí ", "‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ó¶ "]
            #prefix_symbols = ["", "- ", "‚ÄÉ‚ÄÉ- ", "‚ÄÉ‚ÄÉ‚ÄÉ- ", "‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ- "]
            def get_indent_prefix(level):
                return "‚ÄÉ" * level + "‚Ü≥ " if level > 0 else ""
        
            for idx, (level, info) in enumerate(headings):
                part_id = info["id"]
                tieu_de = info["tieu_de"]
                #symbol = prefix_symbols[min(level, len(prefix_symbols) - 1)]
                symbol = get_indent_prefix(level)
        
                progress_item = next(
                    (p for p in st.session_state.get("lesson_progress", []) if p["id"] == part_id),
                    {}
                )
                trang_thai = progress_item.get("trang_thai", "chua_hoan_thanh")
                prefix = "‚úÖ " if trang_thai == "hoan_thanh" else ""
                label = f"{symbol}{prefix}{part_id} ‚Äì {tieu_de}"
        
                options.append(str(idx))
                labels.append(label)
        
            selected_raw = st.radio(
                "Ch·ªçn m·ª•c ƒë·ªÉ h·ªçc:",
                options=options,
                format_func=lambda x: labels[options.index(x)],
                key="selected_part_radio"
            )
        
            if selected_raw != "__none__":
                selected_heading = headings[int(selected_raw)]
                part_id = selected_heading[1]["id"]
        
                selected_part = next((p for p in lesson_parts if p["id"] == part_id), None)
                if selected_part:
                    current = st.session_state.get("selected_part_for_discussion", {})
                    if current.get("id") != part_id:
                        st.session_state["selected_part_for_discussion"] = selected_part
                        st.session_state["force_ai_to_ask"] = True
    
        custom_sidebar_radio(headings)
        # K√≠ch ho·∫°t Firebase m·∫∑c ƒë·ªãnh
        st.session_state["firebase_enabled"] = True

    #ƒë·ªçc b√†i h·ªçc
    # if doc_reading_enabled:
    #     #audio_text = trich_dan_tu_pdf(ten_muc_duoc_chon)  # b·∫°n ƒë√£ c√≥ ƒëo·∫°n tr√≠ch trong n·ªôi dung tr∆∞·ªõc
    #     audio_text = selected_part['noi_dung']
    #     play_audio(audio_text)  # d√πng h√†m TTS s·∫µn c√≥
    #     time.sleep(len(audio_text) * 0.2)  # tu·ª≥ ch·ªânh delay theo th·ªùi l∆∞·ª£ng
        
    #L∆∞u ti·∫øn ƒë·ªô h·ªçc ra file JSON
    if st.button("üíæ L∆∞u ti·∫øn ƒë·ªô h·ªçc"):
        save_lesson_progress()
	
    # üîÑ N√∫t reset
    if st.button("üîÑ B·∫Øt ƒë·∫ßu l·∫°i bu·ªïi h·ªçc"):
        if "messages" in st.session_state:
            del st.session_state.messages
        if "lesson_loaded" in st.session_state:
            del st.session_state.lesson_loaded
        st.rerun()
    
    with st.expander("üì• K·∫øt th√∫c bu·ªïi h·ªçc"):
        if st.button("‚úÖ K·∫øt xu·∫•t n·ªôi dung bu·ªïi h·ªçc th√†nh file .txt v√† PDF"):
            if st.session_state.get("messages"):
                output_text = ""
                for msg in st.session_state.messages[1:]:  # b·ªè prompt h·ªá th·ªëng
                    role = "H·ªçc sinh" if msg["role"] == "user" else "Gia s∆∞ AI"
                    text = msg["parts"][0]["text"]
                    output_text += f"\n[{role}]:\n{text}\n\n"
        
                # ‚úÖ File name base
                lesson_title_safe = st.session_state.get("lesson_source", "BaiHoc_AITutor")
                lesson_title_safe = lesson_title_safe.replace("upload::", "").replace("lesson::", "").replace(" ", "_").replace(":", "")
                txt_file_name = f"BuoiHoc_{lesson_title_safe}.txt"
                pdf_file_name = f"BuoiHoc_{lesson_title_safe}.pdf"
        
                # ‚úÖ N√∫t t·∫£i .txt
                st.download_button(
                    label="üìÑ T·∫£i file .txt",
                    data=output_text,
                    file_name=txt_file_name,
                    mime="text/plain"
                )

                # ƒêƒÉng k√Ω font h·ªó tr·ª£ Unicode
                pdfmetrics.registerFont(TTFont("DejaVu", "Data/fonts/DejaVuSans.ttf"))
        
                # ‚úÖ T·∫°o file PDF t·∫°m
                with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp_pdf:
                    c = canvas.Canvas(tmp_pdf.name, pagesize=letter)
                    c.setFont("DejaVu", 12)  # d√πng font Unicode
                
                    width, height = letter
                    margin = 50
                    y = height - margin
                    lines = output_text.split("\n")
                
                    for line in lines:
                        line = line.strip()
                        if y < margin:
                            c.showPage()
                            c.setFont("DejaVu", 12)
                            y = height - margin
                        c.drawString(margin, y, line)
                        y -= 16
                
                    c.save()
        
                    # ƒê·ªçc l·∫°i file ƒë·ªÉ t·∫£i v·ªÅ
                    with open(tmp_pdf.name, "rb") as f:
                        pdf_bytes = f.read()
        
                    st.download_button(
                        label="üìï T·∫£i file .pdf",
                        data=pdf_bytes,
                        file_name=pdf_file_name,
                        mime="application/pdf"
                    )
            else:
                st.warning("‚ö†Ô∏è Ch∆∞a c√≥ n·ªôi dung ƒë·ªÉ k·∫øt xu·∫•t.")
    
st.title("üéì Tutor AI")

# Nh√∫ng script MathJax
mathjax_script = """
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
"""

st.markdown(mathjax_script, unsafe_allow_html=True)
	
# Load bi·∫øn m√¥i tr∆∞·ªùng
load_dotenv()
#API_KEY = os.getenv("GEMINI_API_KEY")
# ∆Øu ti√™n: D√πng key t·ª´ ng∆∞·ªùi d√πng nh·∫≠p ‚ûù n·∫øu kh√¥ng c√≥ th√¨ d√πng t·ª´ m√¥i tr∆∞·ªùng
API_KEY = input_key or os.getenv("GEMINI_API_KEY")

# Ki·ªÉm tra
if not API_KEY:
    st.error("‚ùå Thi·∫øu Gemini API Key. Vui l√≤ng nh·∫≠p ·ªü sidebar ho·∫∑c thi·∫øt l·∫≠p bi·∫øn m√¥i tr∆∞·ªùng 'GEMINI_API_KEY'.")
    st.stop()

#input file b√†i h·ªçc
#if selected_lesson == "üëâ Ch·ªçn b√†i h·ªçc..." and uploaded_file is None:
if selected_lesson == "üëâ Ch·ªçn b√†i h·ªçc..." and not uploaded_files: #ki·ªÉm tra l√† ƒë√£ t·∫£i li√™n nhi·ªÅu file
    st.info("üì• H√£y t·∫£i l√™n t√†i li·ªáu PDF/TXT ho·∫∑c ch·ªçn m·ªôt b√†i h·ªçc t·ª´ danh s√°ch b√™n tr√™n ƒë·ªÉ b·∫Øt ƒë·∫ßu.") 
    st.stop()

# Endpoint API Gemini
#GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent" 
#GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-03-25:generateContent"
GEMINI_API_URL = st.session_state.get("GEMINI_API_URL", "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent")

#PDF_URL = "https://raw.githubusercontent.com/tranthanhthangbmt/AITutor_Gemini/main/handoutBuoi4.pdf"
#pdf_context = extract_pdf_text_from_url(PDF_URL)
pdf_context = ""

# N·∫øu c√≥ file upload th√¨ l·∫•y n·ªôi dung t·ª´ file upload
if uploaded_files:
    pdf_context = ""
    for uploaded_file in uploaded_files:
        pdf_context += extract_text_from_uploaded_file(uploaded_file) + "\n"

# N·∫øu kh√¥ng c√≥ upload m√† ch·ªçn b√†i h·ªçc th√¨ t·∫£i n·ªôi dung t·ª´ link
elif selected_lesson != "üëâ Ch·ªçn b√†i h·ªçc..." and default_link.strip():
    pdf_context = extract_pdf_text_from_url(default_link)

# N·∫øu kh√¥ng c√≥ g√¨ h·∫øt th√¨ b√°o l·ªói
if not pdf_context:
    st.error("‚ùå B·∫°n c·∫ßn ph·∫£i upload t√†i li·ªáu ho·∫∑c ch·ªçn m·ªôt b√†i h·ªçc ƒë·ªÉ b·∫Øt ƒë·∫ßu.")
    st.stop()

def load_system_prompt_from_file(filepath):
    with open(filepath, "r", encoding="utf-8") as f:
        return f.read()
        
# üîπ Vai tr√≤ m·∫∑c ƒë·ªãnh c·ªßa Tutor AI (tr∆∞·ªõc khi c√≥ t√†i li·ªáu)
#SYSTEM_PROMPT_Tutor_AI = ""
try:
    prompt_path = os.path.join("Data", "system_prompt_tutor_ai.txt")
    SYSTEM_PROMPT_Tutor_AI = load_system_prompt_from_file(prompt_path)
except FileNotFoundError:
    st.error("‚ùå Kh√¥ng t√¨m th·∫•y file Data/system_prompt_tutor_ai.txt")
    st.stop()

# G·ªçi API Gemini, g·ª≠i c·∫£ l·ªãch s·ª≠ tr√≤ chuy·ªán
# Gi·ªõi h·∫°n s·ªë l∆∞·ª£t h·ªôi tho·∫°i g·ª≠i cho Gemini (tr·ª´ prompt h·ªá th·ªëng)
def chat_with_gemini(messages):
    headers = {"Content-Type": "application/json"}
    params = {"key": API_KEY}
    
    # Gi·ªØ prompt h·ªá th·ªëng + 6 t∆∞∆°ng t√°c g·∫ßn nh·∫•t (3 l∆∞·ª£t h·ªèi ‚Äì ƒë√°p)
    truncated = messages[:1] + messages[-6:] if len(messages) > 7 else messages
    data = {"contents": truncated}

    response = requests.post(GEMINI_API_URL, headers=headers, params=params, json=data)

    if response.status_code == 200:
        try:
            return response.json()["candidates"][0]["content"]["parts"][0]["text"]
        except Exception as e:
            return f"L·ªói ph√¢n t√≠ch ph·∫£n h·ªìi: {e}"
    elif response.status_code == 503:
        return None  # model qu√° t·∫£i
    else:
        return f"L·ªói API: {response.status_code} - {response.text}"

# Giao di·ªán Streamlit
#st.set_page_config(page_title="Tutor AI", page_icon="üéì")
#st.title("üéì Tutor AI - H·ªçc To√°n r·ªùi r·∫°c v·ªõi Gemini")

#thi·∫øt l·∫≠p ban ƒë·∫ßu tutor AI
if "messages" not in st.session_state:
    st.session_state.messages = [
        {"role": "user", "parts": [{"text": SYSTEM_PROMPT_Tutor_AI}]},
        {"role": "model", "parts": [{"text": "Ch√†o b·∫°n! M√¨nh l√† gia s∆∞ AI üéì\n\nH√£y ch·ªçn b√†i h·ªçc ho·∫∑c nh·∫≠p link t√†i li·ªáu b√™n sidebar ƒë·ªÉ m√¨nh b·∫Øt ƒë·∫ßu chu·∫©n b·ªã n·ªôi dung bu·ªïi h·ªçc nh√©!"}]}
    ]

import tempfile
import requests

# 1. ƒê·ªçc c√°c file upload v√†o
all_parts = []
uploaded_json = None

if uploaded_files:
    for uploaded_file in uploaded_files:
        file_name = uploaded_file.name.lower()
        uploaded_file.seek(0)
    
        if file_name.endswith(".json"):
            uploaded_json = uploaded_file  # ch·ªâ l∆∞u l·∫°i file json, ch∆∞a ƒë·ªçc v·ªôi
    
        elif file_name.endswith(".pdf"):
            file_bytes = uploaded_file.read()
            with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmpfile:
                tmpfile.write(file_bytes)
                tmpfile_path = tmpfile.name
    
            parts = tach_noi_dung_bai_hoc_tong_quat(tmpfile_path) #parse_pdf_file(tmpfile_path)
            all_parts.extend(parts)
    
        else:
            st.warning(f"‚ö†Ô∏è File {file_name} kh√¥ng h·ªó tr·ª£ t·ª± ƒë·ªông ƒë·ªçc n·ªôi dung b√†i h·ªçc.")
    
        lesson_title = " + ".join([file.name for file in uploaded_files])
        current_source = f"upload::{lesson_title}"

elif selected_lesson != "üëâ Ch·ªçn b√†i h·ªçc..." and default_link.strip():
    # T·∫£i file PDF t·ª´ link v·ªÅ
    response = requests.get(default_link)
    if response.status_code == 200:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmpfile:
            tmpfile.write(response.content)
            tmpfile_path = tmpfile.name
        try:
            parts = tach_noi_dung_bai_hoc_tong_quat(tmpfile_path) #parse_pdf_file(tmpfile_path)
            all_parts.extend(parts)
        finally:
            if os.path.exists(tmpfile_path):
                os.remove(tmpfile_path)

        lesson_title = selected_lesson
        current_source = f"lesson::{selected_lesson}"
    else:
        st.error("Kh√¥ng t·∫£i ƒë∆∞·ª£c file PDF t·ª´ link.")
        all_parts = []

else:
    all_parts = []
    lesson_title = "Ch∆∞a c√≥ b√†i h·ªçc"
    current_source = ""

#xu·∫•t ra TOC file pdf
import pandas as pd

# Sau khi l·∫•y all_parts xong
if all_parts:
    # 1. S·∫Øp x·∫øp
    thu_tu_muc = {
        "ly_thuyet": 1,
        "bai_tap_co_giai": 2,
        "trac_nghiem": 3,
        "luyen_tap": 4,
        "du_an": 5
    }
    parts_sorted = sorted(all_parts, key=lambda x: thu_tu_muc.get(x["loai"], 999))

    # Sinh HTML m·ª•c l·ª•c
    toc_html = "<ul>"
    for part in parts_sorted:
        toc_html += f"<li><strong>{part['id']}</strong> ‚Äì {part['tieu_de']} ({part['loai']})</li>"
    toc_html += "</ul>"
    
    st.session_state["toc_html"] = toc_html  # l∆∞u ƒë·ªÉ d√πng ph√≠a d∆∞·ªõi

    # 2. Hi·ªÉn th·ªã b·∫£ng m·ª•c l·ª•c (m·ª•c l·ª•c tr√™n messages)
    #st.markdown("### üìö **M·ª•c l·ª•c b√†i h·ªçc**")

    
    df = pd.DataFrame(parts_sorted)
    #st.dataframe(df[["id", "loai", "tieu_de"]]) #ƒëang ·∫©n ƒë·ªÉ d√πng n√∫t content

    # 3. L∆∞u session ƒë·ªÉ d√πng ti·∫øp
    st.session_state["lesson_parts"] = parts_sorted

    # üìå Ch·ªçn ph·∫ßn h·ªçc t·ª´ danh s√°ch Content (m·ª•c l·ª•c tr√™n messages)
    # with st.expander("üéØ Ch·ªçn m·ª•c ƒë·ªÉ b·∫Øt ƒë·∫ßu t·ª´ Content", expanded=False):
    #     lesson_part_titles = [f"{part['id']} ‚Äì {part['tieu_de']} ({part['loai']})" for part in st.session_state["lesson_parts"]]
    #     selected_idx = st.selectbox("üîç Ch·ªçn ph·∫ßn h·ªçc ƒë·ªÉ AI ƒë·∫∑t c√¢u h·ªèi:", list(range(len(lesson_part_titles))), format_func=lambda i: lesson_part_titles[i])
    
    #     if st.button("üöÄ B·∫Øt ƒë·∫ßu m·ª•c n√†y"):
    #         selected_part = st.session_state["lesson_parts"][selected_idx]
    #         st.session_state["selected_part_for_discussion"] = selected_part
    #         st.session_state["force_ai_to_ask"] = True
    #         #st.rerun()

    #         # Ch·ªâ gi·ªØ l·∫°i prompt h·ªá th·ªëng ƒë·ªÉ tr√°nh l·∫∑p l·∫°i ph·∫ßn ch√†o h·ªèi
    #         if st.session_state.messages:
    #             st.session_state.messages = [st.session_state.messages[0]]

    # üëâ N·∫øu ng∆∞·ªùi d√πng ch·ªçn m·ªôt ph·∫ßn ‚Üí sinh c√¢u h·ªèi ki·ªÉm tra
    if (
        st.session_state.get("force_ai_to_ask", False)
        and st.session_state.get("selected_part_for_discussion")
        and st.session_state.get("lesson_parts")
    ):
        selected_part = st.session_state["selected_part_for_discussion"]
        question_prompt = f"""
        B√¢y gi·ªù ng∆∞·ªùi h·ªçc ƒë√£ ch·ªçn m·ª•c : "{selected_part['tieu_de']}" trong t√†i li·ªáu ƒë√≠nh k√®m, h√£y ti·∫øp t·ª•c h∆∞·ªõng d·∫´n ng∆∞·ªùi h·ªçc t·ª´ ƒëo·∫°n n√†y theo phong c√°ch ƒë√£ thi·∫øt l·∫≠p t·ª´ ƒë·∫ßu bu·ªïi h·ªçc.
        N·∫øu ph·∫ßn n·ªôi dung n√†y l√† c√°c c√¢u h·ªèi tr·∫Øc nghi·ªám th√¨ tr√≠ch d·∫´n c√¢u tr·∫Øc nghi·ªám ƒë∆∞·ª£c ch·ªçn ƒë√≥ ho·∫∑c n·∫øu l√† nhi·ªÅu c√¢u h·ªèi tr·∫Øc nghi·ªám nh∆∞ng ti√™u ƒë·ªÅ chung kh√¥ng ph·∫£i 1 c√¢u th√¨ l·∫ßn l∆∞·ª£t hi·ªÉn th·ªã c√¢u h·ªèi tr·∫Øc nghi·ªám.
        N·ªôi dung ƒë∆∞·ª£c tr√≠ch ra t·ª´ t√†i li·ªáu ƒë√≠nh k√®m:
        ---
        {selected_part['noi_dung']}
        ---
        """

        question_promptFilter = f"""        
        {selected_part['noi_dung']}
        """
        
        #st.subheader("üß™ N·ªôi dung g·ª≠i l√™n Gemini:")
        #st.code(question_prompt, language="markdown")  # ƒë·ªÉ debug prompt

        
        with st.spinner("ü§ñ ƒêang t·∫°o c√¢u h·ªèi t·ª´ ph·∫ßn b·∫°n ch·ªçn..."):
            user_message = {
                "role": "user",
                "parts": [{"text": question_prompt}]
            }
            user_messageFilter = {
                "role": "user",
                "parts": [{"text": question_promptFilter}]
            }
            #if read_lesson_first:
            st.session_state.messages.append(user_messageFilter)
        
            # üè∑Ô∏è ƒê√°nh d·∫•u index c·ªßa message l√† ph·∫ßn gi·ªõi thi·ªáu b√†i h·ªçc
            if "lesson_intro_indices" not in st.session_state:
                st.session_state["lesson_intro_indices"] = []
            lesson_intro_index = len(st.session_state.messages) - 1
            st.session_state["lesson_intro_indices"].append(lesson_intro_index)
        
            # ‚úÖ Ph√°t audio NGAY n·∫øu b·∫≠t t√≠nh nƒÉng ƒë·ªçc b√†i h·ªçc
            # if st.session_state.get("read_lesson_first", False) and st.session_state.get("enable_audio_playback", True):
            #     render_audio_block(question_prompt, autoplay=True)

            # ‚úÖ Ph√°t audio ngay n·∫øu b·∫≠t ch·∫ø ƒë·ªô ƒë·ªçc b√†i h·ªçc
            # if st.session_state.get("read_lesson_first") and st.session_state.get("enable_audio_playback", True):
            #     render_audio_block(question_prompt, autoplay=True)

            # # üîä Ph√°t audio t·ª± ƒë·ªông n·ªôi dung v·ª´a th√™m            
            # # N·∫øu ng∆∞·ªùi d√πng ch·ªçn checkbox v√† c√≥ n·ªôi dung ƒë·ªÉ ƒë·ªçc
            # if read_lesson_first and question_prompt:
            #     b64 = None
            #     if st.session_state.get("enable_audio_playback", True):
            #         b64 = generate_and_encode_audio(question_prompt)
                
            #     # Hi·ªÉn th·ªã audio player
            #     if b64:
            #         autoplay_attr = "autoplay" if st.session_state.get("enable_audio_playback", True) else ""
            #         st.markdown(f"""
            #         <audio controls {autoplay_attr}>
            #             <source src="data:audio/mp3;base64,{b64}" type="audio/mp3">
            #             Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ph√°t √¢m thanh.
            #         </audio>
            #         """, unsafe_allow_html=True)

            #B∆∞·ªõc 2: G·ª£i √Ω c√°ch vi·∫øt prompt t·ªët (ng·∫Øn + r√µ)
            selected_part = st.session_state["selected_part_for_discussion"]

            #B∆∞·ªõc 3: Hi·ªÉn th·ªã c√¢u h·ªèi AI ph·∫£n h·ªìi
            ai_question = chat_with_gemini(st.session_state.messages)

            #X·ª≠ l√Ω k·∫øt qu·∫£:
            if ai_question is None:
                st.warning("‚ö†Ô∏è Gemini ƒëang qu√° t·∫£i ho·∫∑c ph·∫£n h·ªìi l·ªói. Vui l√≤ng th·ª≠ l·∫°i sau.")
            else:
                ai_question = clean_html_to_text(ai_question)
                #ai_question = format_mcq_options(ai_question)
                #st.chat_message("ü§ñ Gia s∆∞ AI").markdown(ai_question)
                st.session_state.messages.append({"role": "model", "parts": [{"text": ai_question}]})
        
    # ‚úÖ N·∫øu v·ª´a kh√¥i ph·ª•c ti·∫øn ƒë·ªô, th√¥ng b√°o ra
    if st.session_state.get("progress_restored"):
        st.success(f"‚úÖ ƒê√£ kh√¥i ph·ª•c ti·∫øn ƒë·ªô h·ªçc t·ª´ {st.session_state['progress_restored']}.")
        del st.session_state["progress_restored"]

    # N·∫øu t√†i li·ªáu m·ªõi, reset
    if st.session_state.get("lesson_source") != current_source:
        st.session_state["lesson_progress_initialized"] = False
        st.session_state["current_part_index"] = 0

    # Kh·ªüi t·∫°o ti·∫øn ƒë·ªô h·ªçc ch·ªâ 1 l·∫ßn duy nh·∫•t
    uploaded_json = None
    for file in uploaded_files:
        if file.name.endswith(".json"):
            uploaded_json = file
            break
    
    if "lesson_progress_initialized" not in st.session_state or not st.session_state["lesson_progress_initialized"]:
        init_lesson_progress(all_parts)
        st.session_state["lesson_progress_initialized"] = True
    
        # üëâ Merge ngay sau init
        if uploaded_json:
            uploaded_json.seek(0)
            loaded_progress = json.load(uploaded_json)
            merge_lesson_progress(st.session_state["lesson_progress"], loaded_progress)
            st.session_state["progress_restored"] = uploaded_json.name  # üëâ Ghi t√™n file ƒë√£ restore

    # üöÄ ƒê·∫£m b·∫£o current_part_index lu√¥n c√≥
    if "current_part_index" not in st.session_state:
        st.session_state["current_part_index"] = 0
else:
    st.warning("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y n·ªôi dung b√†i h·ªçc ph√π h·ª£p!")
    
# N·∫øu ng∆∞·ªùi h·ªçc ƒë√£ cung c·∫•p t√†i li·ªáu ‚Üí Ghi ƒë√® ƒë·ªÉ b·∫Øt ƒë·∫ßu bu·ªïi h·ªçc
#if (selected_lesson != "üëâ Ch·ªçn b√†i h·ªçc..." or file_url.strip()) and pdf_context:
if pdf_context:
    # ∆Øu ti√™n l·∫•y d√≤ng ti√™u ƒë·ªÅ t·ª´ t√†i li·ªáu
    lesson_title_extracted = None
    for line in pdf_context.splitlines():
        line = line.strip()
        if len(line) > 10 and any(kw in line.lower() for kw in ["bu·ªïi", "b√†i", "b√†i h·ªçc", "ch·ªß ƒë·ªÅ"]):
            lesson_title_extracted = line
            break

    # X√°c ƒë·ªãnh t√™n b√†i h·ªçc h·ª£p l√Ω
    #fallback_name = uploaded_file.name if uploaded_file else selected_lesson
    #fallback_name = uploaded_files[0].name if uploaded_files else selected_lesson
    if uploaded_files:
        fallback_name = " + ".join([f.name for f in uploaded_files])
    elif selected_lesson != "üëâ Ch·ªçn b√†i h·ªçc...":
        fallback_name = selected_lesson
    else:
        fallback_name = "B√†i h·ªçc"
    lesson_title = lesson_title_extracted or fallback_name or "B√†i h·ªçc"

    # G·ªçi Gemini ƒë·ªÉ t√≥m t·∫Øt t√†i li·ªáu
    try:
        response = requests.post(
            GEMINI_API_URL,
            headers={"Content-Type": "application/json"},
            params={"key": API_KEY},
            json={
                "contents": [
                    {"parts": [{"text": f"T√≥m t·∫Øt ng·∫Øn g·ªçn (2-3 c√¢u) n·ªôi dung sau, d√πng vƒÉn phong th√¢n thi·ªán, kh√¥ng li·ªát k√™ g·∫°ch ƒë·∫ßu d√≤ng:\n\n{pdf_context[:2500]}"}]}
                ]
            }
        )
        if response.status_code == 200:
            lesson_summary = response.json()["candidates"][0]["content"]["parts"][0]["text"]
        else:
            lesson_summary = ""
    except Exception as e:
        lesson_summary = ""

    # Gi·ªõi h·∫°n dung l∆∞·ª£ng t√†i li·ªáu ƒë∆∞a v√†o prompt kh·ªüi t·∫°o
    LIMITED_PDF_CONTEXT = pdf_context[:4000]  # ho·∫∑c d√πng tokenizer n·∫øu mu·ªën ch√≠nh x√°c h∆°n
    
    PROMPT_LESSON_CONTEXT = f"""
    {SYSTEM_PROMPT_Tutor_AI}
    
    # B·∫°n s·∫Ω h∆∞·ªõng d·∫´n bu·ªïi h·ªçc h√¥m nay v·ªõi t√†i li·ªáu sau:
    
    ## B√†i h·ªçc: {lesson_title}
    
    --- START OF HANDBOOK CONTENT ---
    {LIMITED_PDF_CONTEXT}
    --- END OF HANDBOOK CONTENT ---
    """

    # Reset session n·∫øu file/t√†i li·ªáu m·ªõi
    if "lesson_source" not in st.session_state or st.session_state.lesson_source != current_source:
        greeting = "M√¨nh ƒë√£ s·∫µn s√†ng ƒë·ªÉ b·∫Øt ƒë·∫ßu bu·ªïi h·ªçc d·ª±a tr√™n t√†i li·ªáu b·∫°n ƒë√£ cung c·∫•p."
        if lesson_summary:
            greeting += f"\n\n{lesson_summary}"
        greeting += "\n\nB·∫°n ƒë√£ s·∫µn s√†ng ch∆∞a?"

        st.session_state.messages = [
            {"role": "user", "parts": [{"text": PROMPT_LESSON_CONTEXT}]},
            {"role": "model", "parts": [{"text": greeting}]}
        ]
        st.session_state.lesson_source = current_source
        st.session_state.lesson_loaded = current_source  # ƒë√°nh d·∫•u ƒë√£ load
        
    #Ph·∫ßn ch·ªçn b√†i h·ªçc
    lesson_title = selected_lesson if selected_lesson != "üëâ Ch·ªçn b√†i h·ªçc..." else "B√†i h·ªçc t√πy ch·ªânh"

    PROMPT_LESSON_CONTEXT = f"""
    {SYSTEM_PROMPT_Tutor_AI}
    
    # B·∫°n s·∫Ω h∆∞·ªõng d·∫´n bu·ªïi h·ªçc h√¥m nay v·ªõi t√†i li·ªáu sau:
    
    ## B√†i h·ªçc: {lesson_title}
    
    --- START OF HANDBOOK CONTENT ---
    {pdf_context}
    --- END OF HANDBOOK CONTENT ---
    """

# Hi·ªÉn th·ªã l·ªãch s·ª≠ chat
for idx, msg in enumerate(st.session_state.messages[1:]):  
    role = "üßë‚Äçüéì H·ªçc sinh" if msg["role"] == "user" else "ü§ñ Gia s∆∞ AI"
    formatted_text = format_pdf_text_for_display(msg["parts"][0]["text"])
    st.chat_message(role).markdown(formatted_text)

    # ‚úÖ Ph√°t audio cho t·∫•t c·∫£ c√°c message c·ªßa Gia s∆∞ AI
    if role == "ü§ñ Gia s∆∞ AI":
        autoplay_setting = st.session_state.get("enable_audio_playback", False)
        render_audio_block(msg["parts"][0]["text"], autoplay=False)

# √î nh·∫≠p c√¢u h·ªèi m·ªõi
user_input = st.chat_input("Nh·∫≠p c√¢u tr·∫£ l·ªùi ho·∫∑c c√¢u h·ªèi...")

if user_input:
    # 1. Hi·ªÉn th·ªã c√¢u tr·∫£ l·ªùi h·ªçc sinh
    st.chat_message("üßë‚Äçüéì H·ªçc sinh").write(user_input)
    st.session_state.messages.append({"role": "user", "parts": [{"text": user_input}]})

    # 2. G·ªçi AI ph·∫£n h·ªìi
    with st.spinner("ü§ñ ƒêang ph·∫£n h·ªìi..."):
        # L·∫•y ph·∫ßn h·ªçc hi·ªán t·∫°i
        uncompleted_parts = [part for part in st.session_state["lesson_progress"] if part["trang_thai"] != "hoan_thanh"]

        if not uncompleted_parts:
            st.success("üéâ B·∫°n ƒë√£ ho√†n th√†nh to√†n b·ªô b√†i h·ªçc! Ch√∫c m·ª´ng!")
            st.stop()
        
        # Ch·ªçn ph·∫ßn ch∆∞a ho√†n th√†nh ƒë·∫ßu ti√™n
        current_part = uncompleted_parts[0]
        
        # G√°n lu√¥n current_part_id
        st.session_state["current_part_id"] = current_part["id"]
        
        # T·∫°o prompt tutor AI d·ª±a tr√™n n·ªôi dung ph·∫ßn hi·ªán t·∫°i
        prompt = f"""
        D·ª±a tr√™n n·ªôi dung sau, h√£y ƒë·∫∑t 1 c√¢u h·ªèi ki·ªÉm tra hi·ªÉu bi·∫øt cho h·ªçc sinh, r·ªìi ch·ªù h·ªçc sinh tr·∫£ l·ªùi:
        ---
        {current_part['noi_dung']}
        ---
        H√£y ƒë·∫∑t c√¢u h·ªèi ng·∫Øn g·ªçn, r√µ r√†ng, li√™n quan tr·ª±c ti·∫øp ƒë·∫øn n·ªôi dung tr√™n.
        """
        
        reply = chat_with_gemini(st.session_state.messages)

        # N·∫øu c√≥ th·ªÉ xu·∫•t HTML (nh∆∞ <p>...</p>)
        reply = clean_html_to_text(reply)
        
        # X·ª≠ l√Ω tr·∫Øc nghi·ªám t√°ch d√≤ng
        reply = format_mcq_options(reply)

        if st.session_state.get("firebase_enabled", False):
            save_exchange_to_firestore(
                user_id=st.session_state.get("user_id", f"user_{uuid.uuid4().hex[:8]}"),
                lesson_source=st.session_state.get("lesson_source", "Chua_xac_dinh"),
                question=user_input,
                answer=reply,
                session_id=st.session_state.get("session_id", "default")
            )
        
        # 3. Hi·ªÉn th·ªã ph·∫£n h·ªìi
        st.chat_message("ü§ñ Gia s∆∞ AI").markdown(reply)

        # ‚úÖ G·ªçi audio ngay sau hi·ªÉn th·ªã
        autoplay_setting = st.session_state.get("enable_audio_playback", False)
        render_audio_block(reply, autoplay=False)

        # Sau ƒë√≥ m·ªõi append v√†o session_state ƒë·ªÉ l∆∞u
        st.session_state.messages.append({"role": "model", "parts": [{"text": reply}]})

  		# üöÄ T·ª∞ ƒê·ªòNG CH·∫§M ƒêI·ªÇM
        scoring_prompt = f"""
	    Ch·∫•m ƒëi·ªÉm c√¢u tr·∫£ l·ªùi sau tr√™n thang ƒëi·ªÉm 0‚Äì100, ch·ªâ tr·∫£ v·ªÅ s·ªë, kh√¥ng gi·∫£i th√≠ch.
	    ---
	    C√¢u tr·∫£ l·ªùi: {user_input}
	    ---
	    """
     
        diem_raw = chat_with_gemini([
	        {"role": "user", "parts": [{"text": scoring_prompt}]}
	    ])
     
        try:
	        diem_so = int(re.findall(r"\d+", diem_raw)[0])
        except:
            diem_so = 90  # fallback n·∫øu c√≥ l·ªói
        
	    # C·∫≠p nh·∫≠t ti·∫øn ƒë·ªô
        update_progress(
            #part_id=st.session_state.get("current_part_id", "UNKNOWN_PART"),
            part_id=current_part["id"],
            trang_thai="hoan_thanh",
            diem_so=diem_so
        )

        #Khi h·ªçc sinh tr·∫£ l·ªùi xong ‚Üí ch·∫•m ƒëi·ªÉm ‚Üí c·∫≠p nh·∫≠t ti·∫øn ƒë·ªô cho
        st.session_state["current_part_index"] += 1

        # üöÄ Bu·ªôc ch·∫°y l·∫°i ƒë·ªÉ message m·ªõi ƒë∆∞·ª£c render audio trong v√≤ng for
        #!st.rerun()
    
        # b64 = generate_and_encode_audio(reply)
        # b64 = None
        # if st.session_state.get("enable_audio_playback", True):
        #     b64 = generate_and_encode_audio(reply)
        #     render_audio_block(reply, autoplay=True)
        
        # # Hi·ªÉn th·ªã n√∫t nghe
        # if b64:
        #     autoplay_attr = "autoplay" if st.session_state.get("enable_audio_playback", True) else ""
        #     st.markdown(f"""
        #     <audio controls {autoplay_attr}>
        #         <source src="data:audio/mp3;base64,{b64}" type="audio/mp3">
        #         Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ph√°t √¢m thanh.
        #     </audio>
        #     """, unsafe_allow_html=True)

    # Chuy·ªÉn bi·ªÉu th·ª©c to√°n trong ngo·∫∑c ƒë∆°n => LaTeX inline
    #reply = convert_parentheses_to_latex(reply)
    #reply_processed = convert_to_mathjax1(reply)

    # Hi·ªÉn th·ªã Markdown ƒë·ªÉ MathJax render c√¥ng th·ª©c
    #st.chat_message("ü§ñ Gia s∆∞ AI").markdown(reply_processed)
    #st.chat_message("ü§ñ Gia s∆∞ AI").markdown(reply)

    # L∆∞u l·∫°i ph·∫£n h·ªìi g·ªëc
    #st.session_state.messages.append({"role": "model", "parts": [{"text": reply}]})

    #Khi h·ªçc sinh tr·∫£ l·ªùi xong ‚Üí ch·∫•m ƒëi·ªÉm ‚Üí c·∫≠p nh·∫≠t ti·∫øn ƒë·ªô cho
    # st.session_state["current_part_index"] += 1
